

-- Load Rayfield and create the window
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "Rayfield Example Window",
    LoadingTitle = "Rayfield Interface Suite",
    LoadingSubtitle = "by Sirius",
    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "Big Hub"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Untitled",
       Subtitle = "Key System",
       Note = "No method of obtaining the key is provided",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
})

local Tab = Window:CreateTab("Tab Example", 4483362458) -- Title, Image
local Section = Tab:CreateSection("Section Example")

local HttpService = game:GetService("HttpService")
local username = game.Players.LocalPlayer.Name
local visible = false

local Toggle = Tab:CreateToggle({
    Name = "Auto Fruit Server Hop",
    CurrentValue = autoserverhop,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(state)
        if state then
            local function teleportToPart(player, part)
                if player and player.Character and part then
                    player.Character:SetPrimaryPartCFrame(part.CFrame)
                    return true
                end
                return false
            end

            local function teleportToAllHandles()
                local tools = game.Workspace:GetChildren()
                local teleportedHandles = {}

                for _, tool in ipairs(tools) do
                    if tool:IsA("Tool") then
                        local handles = tool:GetChildren()
                        for _, handle in ipairs(handles) do
                            if handle.Name == "Handle" and handle:IsA("MeshPart") then
                                local player = game.Players.LocalPlayer
                                if teleportToPart(player, handle) then
                                    table.insert(teleportedHandles, "**" .. handle.Parent.Name .. "**")
                                    print("Teleported to handle:", handle:GetFullName())
                                    wait(1)

                                    function getNil(name, class, workspaceRef)
                                        local toolName = type(name) == "table" and workspaceRef[name[1]][name[2]][name[3]].Name or name
                                        for _, v in ipairs(workspaceRef:GetChildren()) do
                                            if v.ClassName == class and v.Name == toolName then
                                                return v
                                            end
                                        end
                                    end
                                    local workspaceRef = game.Workspace:WaitForChild("__GAME"):WaitForChild("__Players"):WaitForChild("Jukiye2uwu6")
                                    local toolName = workspaceRef:FindFirstChildOfClass("Tool").Name
                                    local args = {
                                        [1] = {
                                            [1] = {
                                                [1] = "\4",
                                                [2] = "EatFruit",
                                                [3] = getNil(toolName, "Tool", workspaceRef),
                                                [4] = "Storage"
                                            }
                                        }
                                    }
                                    game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
                                    wait(2)
                                else
                                    warn("Failed to teleport player to Handle:", handle:GetFullName())
                                end
                            end
                        end
                    end
                end

                return teleportedHandles
            end

            local teleportedHandles = teleportToAllHandles()

            local embedMessage = {
                title = "**Leaf Hub**",
                color = tonumber(0xFF0000),
                description = "",
                fields = {
                    {
                        name = "**Username:**",
                        value = username
                    }
                }
            }

            if #teleportedHandles > 0 then
                embedMessage.description = "**Status:** Serverhopping\n**FruitsFound:** " .. table.concat(teleportedHandles, ", ")
            else
                embedMessage.description = "**Status:** Serverhopping\n**FruitsFound:** None"
            end

            local response = syn.request({
                Url = WebhookUrl,
                Method = 'POST',
                Headers = {
                    ['Content-Type'] = 'application/json'
                },
                Body = HttpService:JSONEncode({
                    embeds = {embedMessage}
                })
            })

            print("Webhook Status Code:", response.StatusCode)
            print("Webhook Response Body:", response.Body)

            wait(10)
            local success, errorMessage = pcall(function()
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId)
            end)

            if success then
                print("Server hop successful.")
            else
                print("Error while attempting to server hop:", errorMessage)
            end

            visible = not visible
            if visible then
                embedMessage.fields[1].value = nil
            else
                embedMessage.fields[1].value = username
            end

            local updatedResponse = syn.request({
                Url = WebhookUrl,
                Method = 'POST',
                Headers = {
                    ['Content-Type'] = 'application/json'
                },
                Body = HttpService:JSONEncode({
                    embeds = {embedMessage}
                })
            })

            print("Updated Webhook Status Code:", updatedResponse.StatusCode)
            print("Updated Webhook Response Body:", updatedResponse.Body)
        end
    end
})

Rayfield:LoadConfiguration()
